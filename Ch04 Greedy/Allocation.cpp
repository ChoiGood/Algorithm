//활동 선택 문제: 회의실 배정

#include <iostream>
#include <vector>

using namespace std;

void InputSF(int n,vector<int> &s, vector<int> &f)
{
    for(int i=1;i<=n;i++) {
        cin >> s[i] >> f[i];
    }
}

void PrintV(int n,vector<int> &v)
{
    for(int i=1;i<n;i++) {
        cout << v[i] << " ";
    }
    cout << v[n] << endl;
}
vector<int> S;

void Selection(int n, vector<int> &s, vector<int> &f)
{
    S.clear();
    int F=0;
    for(int i=1; i<=n; i++) {
        if (F <= s[i]) {
            S.push_back(i);
            F = f[i];
        }
    }    
}




int main()
{
    int n; cin >> n;
    vector<int> s(n+1); vector<int> f(n+1);

    InputSF(n,s,f);
    // 우리 문제의 Input 은 종료시간이 오름차운으로 정렬되어 있으므로 정렬시킬 필요가 없었지만
    // 만약 정렬이 되어지지않았응ㄹ 경우 정렬 시켜야한다!!
    Selection(n,s,f);
    cout << S.size() << endl;
    for(int i=0; i<S.size(); i++) {
        cout << s[S[i]] << " " << f[S[i]] << endl;
    }


    return 0;
}

/*
Description
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 시간표를 만들려고 한다.
각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고,
각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 이싿.
회의ㅣ의 시작시간과 끝나는 시간이 같을 수도 있다.
이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

---
이 회의실 배정 문제는 활동 선택 문제(Activity Selection Problem)의 일종으로
다음과 같은 알고리즘으로 풀 수 이싿.
알고리즘: 회의실배정(n,s,f)
입력: 회의 개수 n, 시작시간 배열 s. 종료시간 배열 f
단, 입력값은 회의가 끝나는 시간의 오름차순을 정렬되어 있다.(f1 <= f2 <= ... <= fn)

절차
1. A집합에 첫번째 회의를 추가한다.
2. 두번째 회의에서 n번째 회의까지 
   A 집합의 회의들과 동시에 개최가능한 회의를 A 집합에 추가한다.

질문 1. Brute-Force로 풀려면 확인해야 하는 경우의 수는 총 몇 가지인가?
질문 2. 이 문제를 재귀적 관계로 정의할 수 있는가?
질문 3. 이 문제를 재귀적으로 풀면 부분 중복 문제가 발생하는가?
질문 4. 이 문제를 동적계획법으로 풀 수 있는가? (부분 최적 구조를 가지는가?)
질문 5. 이문제를 탐욕법으로 풀 수 있는가? (탐욕적 접근법이 부분 최적 구조를 가지는가?)

위의 질문을 바탕으로 이 문제를 해결해보라.
단, 이 문제의 최적해는 여러 개 있을 수 있으므로, 최적해는 위의 Greedy 알고리즘의 결과물을 최적해로 출력해야한다.

알고리즘 해설은 유튜브 영상 참고:https://youtu.be/1oKQPpvcPy8

Input
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다.

둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데

이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다.

시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

단, 회의의 순서는 빨리 끝나는 회의의 순서대로 주어진다고 가정해도 된다.


Output
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수 T를 출력한다.

둘째 줄부터 개최할 수 있는 T개의 회의를 한 줄에 하나씩 출력한다.

이 때 출력되는 순서는 입력에서 주어진 순서대로 출력한다.
*/

/*
Sample Input 1 

11
1 4
3 5
0 6
5 7
3 9
5 9
6 10
8 11
8 12
2 14
12 16
Sample Output 1

4
1 4
5 7
8 11
12 16
*/